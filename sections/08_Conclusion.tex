\chapter{Conclusion}
\label{chapter:conclusion}

This chapter provides the conclusions we draw from this thesis, by first summarizing its results and by outlining the directions for future work on \textsc{Tavor}.

\section{Summary}
\label{sec:summary}

In general both testing and debugging software are cumbersome as well as error prone tasks which would strongly benefit from automated techniques. Fuzzing and delta-debugging are such techniques, which are very well known in literature. In this thesis we devised the \textsc{Tavor framework} that utilizes both approaches by operating on the same data model.

Especially in times where programming skills are such a rare trait, tools and techniques are needed which enable also non-programmers to apply automated testing techniques. For this reason, we designed the \textsc{Tavor Format}, which is used to specify the data model on which the \textsc{Tavor framework} operates on. This format enables also testers without any programming skills to define the data models that are needed for fuzzing and delta-debugging. Additionally, the \textsc{Tavor CLI} can be used to utilized the capabilities of the \textsc{Tavor framework} without the need to write any source code.

In our evaluation we demonstrated how the \textsc{Tavor framework}, format and CLI may be combined to efficiently test and debug software programs using the example of a simple coin vending machine. We used \textsc{go-mutesting}, a by-product of this thesis, to introduce bugs into the coin vending machine and validate the generated test suite. In addition to the coin vending machine case study we compared the fuzzing capabilities of the \textsc{Tavor framework} for the AIGER ASCII format with the \emph{aigfuzz} command. In total 16 commands of the AIGER toolset were evaluated to compare the generated test sets. On average the random fuzzing strategy of the \textsc{Tavor Framework} reached \texttt{9.16\%} more line coverage than \emph{aigfuzz}. The best result has been obtained for the \texttt{aigor} command, where \emph{aigfuzz} covered \texttt{43.9\%} and the \textsc{Tavor Framework} \texttt{59.16\%}. Additionally to the random fuzzing strategy the \emph{AlmostAllPermutations} fuzzing strategy was used to accurately generate a small test suite, which reached for 13 commands on average \texttt{3.32\%} more coverage than \emph{aigfuzz} and for the command \texttt{aigunroll} \texttt{37.28\%} more coverage, which surpassed even \textsc{Tavor}'s random fuzzing strategy. Our third and last evaluation compared the fuzzing capabilities of the \textsc{Tavor framework} to the manually written test suite of \textsc{Go}'s JSON implementation \texttt{encoding/json}. No additional statement coverage was achieved. However, using \textsc{go-mutesting} to apply mutation testing revealed two killed mutations with the test sets generated by \textsc{Tavor}, i.e., the code paths of these mutations are not checked by the original test suite. Therefore, if the behavior of the code changes, these cases will not be caught by the manually written test suite.

The \textsc{Tavor} project as well as \textsc{go-mutesting} have been published as open source repositories. Both enjoy great popularity in the open source and \textsc{Go} community, even though they focus on specialized techniques. At the time of writing \textsc{Tavor} is cloned on average 3.5 times per day by unique persons and holds a rating of 172 stars, i.e., 172 persons value the publication of this repository. The \textsc{go-mutesting} repository is cloned on average twice a day and holds 117 stars. Similar popularity can be seen for the other contributions outlined in Section~\ref{sec:contributions}. Especially the major contributions to the \emph{go-flags} package should be emphasized, since they led to the maintainership of this package, which holds now a rating of 918 stars and is cloned on average over 750 times per day. The \emph{go-flags} package is also now one of the de facto standard packages to parse command line options and configurations. All of these statistics attest that the contributions of this master thesis are actively used and therefore significant.

In conclusion we successfully showed that this master thesis meets its goals of providing a generic fuzzing and delta-debugging framework, which can also be utilized by non-programmers. However, there are still many options for future improvements of the \textsc{Tavor framework} which are outlined in the next section.

\section{Future Work}
\label{sec:futureWork}

This master thesis touches a wide variety of topics. Of course, not all of them have been explored completely. Indeed there is a great number of options for future improvements of the \textsc{Tavor Framework}. In this section we chose to outline those with the most impact to the applicability of \textsc{Tavor}.

A substantial improvement to the \textsc{Tavor framework} would be to ensure that the \textsc{Tavor format} as well as the fuzzing and delta-debugging capabilities of the framework offer the same functionality. The fuzzing capability of the framework is currently the most advanced concept as it is capable of handling all token types\footnote{Tokens, introduced in Section~\ref{sec:tokens}, are the basic building blocks of the \textsc{Tavor Framework}.} of the framework. While the delta-debugging capability of the framework does support reducing all sorts of groups, repetitions and character classes, it does not yet support more advanced token concepts such as variables and attributes. Also the \textsc{Tavor format} is not expressive enough to model all token concepts, e.g., state variables. However, please keep in mind that the format does meet its original goal of being expressive enough to model the AIGER ASCII format.

Another direction of future work is the redesign of the used data structures. Currently, graph structures are used to represent the formats to operate on. These graph structures are very well suited for storing formats, but it is cumbersome to ensure that all dependencies are met while performing operations on them. An example of such dependencies are token attributes, where changing the value of one token needs to be propagated to all tokens referencing that value by a token attribute. Rather than using graph structures for representing formats, we propose to switch to an event-driven architecture. Whenever a certain token value changes, this change can then be propagated to all registered listeners of a token. This redesign has also the advantage that most fuzzing and reducing strategies are easier to implement.

Today the goal of fuzzing is mainly to find faults in programs under test. A \textsc{Tavor format} may be used to describe the structure of the data which should be used as an input. We strongly believe that a dedicated fuzzing strategy, which aims to execute all paths through the token graph of a format, is likely to gain higher code coverages with its generated test suites. Consider for instance a format for fuzzing command line options of a command. Repeatedly fuzzing a single parameter with different arguments may soon exhaust all paths that are reachable with this certain parameter. However, all other parameters of the command would not have been tested yet. The proposed dedicated fuzzing strategy aims to first visit each token in the token graph at least once, so that all paths of the token graph are covered, and therefore all parameters of the command of this example. Hence, resulting in a high code coverage for the program under test. Please note, that such a strategy is costly to implement. It requires, for instance, the use of a constraint solver in order to be able to specifically target each path through the token graph.

Currently a dedicated executor needs to be provided to enhance fuzzing and delta-debugging in an automated fashion. The addition of an execution layer to the \textsc{Tavor framework} would have the advantage that these executors no longer need to be provided by programmers. Such an execution layer in combination with the support for real loops, instead of unrolling loops, would enable online fuzzing, i.e., the continuous feeding of data to a program under test. As long as loop unrolling is used as a replacement for real loops it is not possible to provide an executable with an endless stream of randomly generated data. Another useful extension on top of online fuzzing is feedback-driven fuzzing, where profiling techniques are used to determine which permutations led to further code coverage in the program under test. This information is then used to guide the fuzzing strategy.

The future extensions presented in this section are just the highlights, which would bring the most benefits to the end-users of the \textsc{Tavor framework}. There are also lots of minor feature suggestions in the issue tracker of the \textsc{Tavor} repository, which can be easily implemented even by novice programmers. We would be delighted if the work started with this master thesis would be carried on, in order to provide an even better tool for applying fuzzing and delta-debugging.
